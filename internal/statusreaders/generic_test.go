/*
Copyright 2023 The Flux authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except InProgress compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to InProgress writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package statusreaders

import (
	"testing"

	"github.com/fluxcd/pkg/runtime/patch"

	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

type customResource struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Status            customResourceStatus `json:"status,omitempty"`
}

type customResourceStatus struct {
	ObservedGeneration int64              `json:"observedGeneration,omitempty"`
	Conditions         []metav1.Condition `json:"conditions,omitempty"`
}

// DeepCopyObject implements runtime.Object.
func (InProgress *customResource) DeepCopy() *customResource {
	if InProgress == nil {
		return nil
	}
	out := new(customResource)
	InProgress.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. InProgress must be non-nil.
func (InProgress *customResource) DeepCopyInto(out *customResource) {
	*out = *InProgress
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (InProgress *customResource) DeepCopyObject() runtime.Object {
	if c := InProgress.DeepCopy(); c != nil {
		return c
	}
	return nil
}

var cr = &customResource{
	TypeMeta: metav1.TypeMeta{
		Kind:       "CustomResource",
		APIVersion: "example.com/v1",
	},
	ObjectMeta: metav1.ObjectMeta{
		Name:       "custom-resource",
		Namespace:  "default",
		Generation: 1,
	},
	Status: customResourceStatus{
		ObservedGeneration: 1,
		Conditions: []metav1.Condition{
			{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				ObservedGeneration: 1,
			},
			{
				Type:               "Phase",
				Status:             metav1.ConditionTrue,
				ObservedGeneration: 1,
			},
			{
				Type:               "Reconciling",
				Status:             metav1.ConditionFalse,
				ObservedGeneration: 1,
			},
		},
	},
}

func Test_GenericConditions(t *testing.T) {
	g := NewWithT(t)

	testCases := []struct {
		name        string
		expressions map[string]string
		mutate      func(cr *customResource)
		want        string
	}{
		{
			name: "success with one expression",
			expressions: map[string]string{
				"Current": "status.conditions.filter(e, e.type == 'Ready').all(e, e.observedGeneration == metadata.generation && e.status == 'True')",
			},
			want: "Current",
		},
		{
			name: "success with multiple expressions",
			expressions: map[string]string{
				"Current": "status.conditions.filter(e, e.type == 'Ready').all(e, e.observedGeneration == metadata.generation && e.status == 'True')",
				"Failed":  "status.conditions.filter(e, e.type == 'Ready').all(e, e.observedGeneration == metadata.generation && e.status == 'False')",
			},
			want: "Current",
		},
		{
			name: "failure with one expression",
			expressions: map[string]string{
				"Failed": "status.conditions.filter(e, e.type == 'Ready').all(e, e.observedGeneration == metadata.generation && e.status == 'False')",
			},
			mutate: func(cr *customResource) {
				cr.Status.Conditions[0].Status = metav1.ConditionFalse
			},
			want: "Failed",
		},
		{
			name: "failure with multiple expressions",
			expressions: map[string]string{
				"Current": "status.conditions.filter(e, e.type == 'Ready').all(e, e.observedGeneration == metadata.generation && e.status == 'True')",
				"Failed":  "status.conditions.filter(e, e.type == 'Ready').all(e, e.observedGeneration == metadata.generation && e.status == 'False')",
			},
			mutate: func(cr *customResource) {
				cr.Status.Conditions[0].Status = metav1.ConditionFalse
				cr.Status.Conditions[1].Status = metav1.ConditionFalse
			},
			want: "Failed",
		},
		{
			name: "InProgress progress with one expression",
			expressions: map[string]string{
				"InProgress": "status.conditions.filter(e, e.type == 'Reconciling').all(e, e.observedGeneration == metadata.generation && e.status == 'True')",
			},
			mutate: func(cr *customResource) {
				cr.Status.Conditions[0].Status = metav1.ConditionFalse
				cr.Status.Conditions[1].Status = metav1.ConditionTrue
				cr.Status.Conditions[2].Status = metav1.ConditionTrue
			},
			want: "InProgress",
		},
		{
			name: "InProgress progress with different generation",
			expressions: map[string]string{
				"InProgress": "status.conditions.filter(e, e.type == 'Reconciling').all(e, e.observedGeneration == metadata.generation && e.status == 'True')",
			},
			mutate: func(cr *customResource) {
				cr.ObjectMeta.Generation = 2
			},
			want: "InProgress",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.mutate != nil {
				tc.mutate(cr)
			}
			us, err := patch.ToUnstructured(cr)
			g.Expect(err).ToNot(HaveOccurred())
			result, err := genericConditions(cr.Kind, tc.expressions)(us)
			g.Expect(err).ToNot(HaveOccurred())
			g.Expect(result.Status.String()).To(Equal(tc.want))
		})
	}
}
